function [ varout ] = c2_vC2vB( varin )
%c2_vC2vB Convert variables from Cryosat Baseline C NetCDF file to
%         Baseline B equivalents

% First the 1Hz data - doubles are just copied
v.v_01_dbl = struct(...
  'time',                         'time_01',...
  'utc_time',                     'time_01',...
  'time_offset',                  '',...
  'lat',                          'lat_01',...
  'lon',                          'lon_01',...
  'agc',                          'agc_01_ku',...
  'corr_agc',                     'agc_cor_01',...
  'corr_atm_atten',               'atm_cor_sig0_01',...
  'corr_cog',                     'cog_cor_01',...
  'corr_dac',                     'hf_fluct_cor_01',...
  'corr_dopp',                    'dop_cor_01_ku',...
  'corr_dry_trop',                'mod_dry_tropo_cor_01',...
  'corr_instr',                   'mod_instr_cor_range_01_ku',...
  'corr_int_cal1',                'int_path_cor_01',...
  'corr_inv_baro',                'inv_bar_cor_01',...
  'corr_iono_gim',                'iono_cor_gim_01',...
  'corr_sigma0_instr',            'mod_instr_cor_sig0_01_ku',...
  'corr_sigma0_int_cal1',         'internal_cor_sig0_01',...
  'corr_ssb',                     'sea_state_bias_01_ku',...
  'corr_swh_instr',               'mod_instr_cor_swh_01_ku',...
  'corr_uso',                     'uso_cor_01_ku',...
  'corr_wet_trop_mod',            'mod_wet_tropo_cor_01',...
  'h',                            'ssha_01_ku',...
  'h_dem',                        '',...
  'h_geoid',                      'geoid_01',...
  'h_long_period_ocn_tide',       'ocean_tide_eq_01',...
  'h_long_period_ocn_tide_no_eq', 'ocean_tide_non_eq_01',...
  'h_mdt',                        'mean_dyn_topo_sol1_01',...
  'h_mss1',                       'mean_sea_surf_sol1_01',...
  'h_mss2',                       'mean_sea_surf_sol2_01',...
  'h_rate',                       'orb_alt_rate_01',...
  'h_tide_geocen_pole',           'pole_tide_01',...
  'h_tide_load_sol1',             'load_tide_sol1_01',...
  'h_tide_load_sol2',             'load_tide_sol2_01',...
  'h_tide_solid',                 'solid_earth_tide_01',...
  'h_tot_geocen_ocn_tide_sol1',   'ocean_tide_sol1_01',...
  'h_tot_geocen_ocn_tide_sol2',   'ocean_tide_sol2_01',...
  'off_nad_ang_sq_wvform',        'off_nadir_angle_wf_ocean_01_ku',...
  'pp' ,                          'peakiness_01_ku',...
  'range',                        'range_ocean_01_ku',...
  'range_ice',                    'range_ocog_01_ku',...
  'range_sd',                     'range_ocean_rms_01_ku',...
  'range_ice_sd',                 'range_ocog_rms_01',...
  'sigma0',                       'sig0_ocean_01_ku',...
  'sigma0_ice',                   'sig0_ocog_01_ku',...
  'sigma0_ice_sd',                'sig0_ocog_rms_01_ku',...
  'sigma0_sd',                    'sig0_ocean_rms_01_ku',...
  'swh',                          'swh_ocean_01_ku',...
  'swh_sd',                       'swh_ocean_rms_01_ku',...
  'swh_sq',                       'square_swh_ocean_01_ku',...
  'wsp',                          'wind_speed_alt_01_ku',...
  'wsp_u_mod',                    'wind_speed_mod_u_01',...
  'wsp_v_mod',                    'wind_speed_mod_v_01'...
  );
% 1Hz integers
v.v_01_int = struct(...
  'rec_cnt','seq_count_01',...
  'range_ice_num','range_ocog_numval_01',...
  'range_num','range_ocean_numval_01_ku',...
  'sigma0_num','sig0_ocean_numval_01_ku',...
  'sigma0_ice_num','sig0_ocog_numval_01_ku',...
  'swh_num','swh_ocean_numval_01_ku',...
  'flag_surface_type','surf_type_01'...
  );
vn={'v_01_dbl', 'v_01_int'};
for i=1:length(vn)
  flds = fieldnames(v.(vn{i}));
  for j=1:length(flds)
    if isempty(v.(vn{i}).(flds{j}))
      disp(['No matching fieldname for ' flds{j}]);
    elseif isempty(varin.(v.(vn{i}).(flds{j})))
      disp(['No matching data  for field' flds{j}]);
    else
      %       varout.(flds{j}) = cast(varin.(v.(vn{i}).(flds{j})), 'int16');
      varout.(flds{j}) = varin.(v.(vn{i}).(flds{j}))';
    end
  end
end

% 20Hz MAY data need to be reshaped - lets try without for now!
ind1 = 20-varin.ind_first_meas_20hz_01(2); % 0 based index first 20Hz measurement in 1Hz
n_01 = length(varin.time_01);
n_20 = length(varin.time_20_ku);

% % This is checking that we have 20 records for all but first and last
% %  If any other records flagged up, we need to be smarter...
% ind = varin.ind_meas_1hz_20_ku; % 0 based index of each 20Hz measurement to 1Hz
% for i=1:n_01
%   nrec = length(find(ind==i-1));
%   if nrec~=20 && i>1 && i<n_01
%     fprintf('Record %d has %d 20Hz records\n',i,nrec);
%   end
% end
fprintf('Max. No 20Hz records / 1Hz : %d\n', max(varin.num_meas_20hz_01));

% Start with doubles
v.v_20_dbl = struct(...
  'hi_time',        'time_20_ku',...
  'hi_utctime',     'time_20_ku',...
  'hi_h',           'ssha_20_ku',...
  'hi_lat',         'lat_20_ku',...
  'hi_lon',         'lon_20_ku',...
  'hi_pp',          'peakiness_20_ku',...
  'hi_range',       'range_ocean_20_ku',...
  'hi_range_ice',   'range_ocog_20_ku',...
  'hi_sigma0',      'sig0_ocean_20_ku',...
  'hi_sigma0_ice',  'sig0_ocog_20_ku',...
  'hi_sigma0_scale','scale_factor_20_ku',...
  'hi_swh',         'swh_ocean_20_ku',...
  'tdiff',          '',...
  'trk_error',      ''...
  );

%blanks = nan(20,n_01); % empty matrix for adding data

% 20Hz 32 bit integers
% cls = 'uint32';
v.v_20_int32 = struct(...
  'tdiff_offset', '',...
  'meas_conf_wd', 'flag_mcd_20_ku'...
  );
% flds = fieldnames(v_20_int32);
% % blanks = cast(ones(20,n_01), cls).*intmin(cls); % empty matrix for adding data
% for i=1:length(flds)
%   if isempty(v_20_int32.(flds{i}))
%     disp(['No matching field for ' flds{i}]);
%   else
%     %     varout.(flds{i}) = blanks;
%     %     varout.(flds{i})(ind1:ind1+n_20-1) = cast(varin.(v_20_int32.(flds{i})), cls);
%     varout.(flds{i}) = cast(varin.(v_20_int32.(flds{i})), cls);
%   end
% end

% 20Hz 8 bit integers
% cls = 'int8';
v.v_20_int8 = struct(...
  'flag_mcd_block_degraded',        'flag_mcd_block_degraded',...
  'flag_mcd_blank_block',           'flag_mcd_blank_block',...
  'flag_mcd_datation_degraded',     'flag_mcd_datation_degraded',...
  'flag_mcd_orbit_prop_error',      'flag_mcd_orbit_prop_error',...
  'flag_mcd_orbit_file_change',     'flag_mcd_orbit_file_change',...
  'flag_mcd_orbit_gap',             'flag_mcd_orbit_gap',...
  'flag_mcd_echo_saturated',        'flag_mcd_echo_saturated',...
  'flag_mcd_other_echo_error',      'flag_mcd_other_echo_error',...
  'flag_mcd_sarin_rx1_error',       'flag_mcd_sarin_rx1_error',...
  'flag_mcd_sarin_rx2_error',       'flag_mcd_sarin_rx2_error',...
  'flag_mcd_window_delay_error',    'flag_mcd_window_delay_error',...
  'flag_mcd_agc_error',             'flag_mcd_agc_error',...
  'flag_mcd_cal1_missing',          'flag_mcd_cal1_missing',...
  'flag_mcd_cal1_default',          'flag_mcd_cal1_default',...
  'flag_mcd_doris_uso_missing',     'flag_mcd_doris_uso_missing',...
  'flag_mcd_ccal1_default',         'flag_mcd_ccal1_default',...
  'flag_mcd_trk_echo_error',        'flag_mcd_trk_echo_error',...
  'flag_mcd_echo_rx1_error',        'flag_mcd_echo_rx1_error',...
  'flag_mcd_echo_rx2_error',        'flag_mcd_echo_rx2_error',...
  'flag_mcd_npm_error',             'flag_mcd_npm_error',...
  'flag_mcd_azimuth_cal_missing',   'flag_mcd_azimuth_cal_missing',...
  'flag_mcd_phase_pert_cor_missing','flag_mcd_phase_pert_cor_missing',...
  'flag_mcd_cal2_missing',          'flag_mcd_cal2_missing',...
  'flag_mcd_cal2_default',          'flag_mcd_cal2_default',...
  'flag_mcd_power_scale_error',     'flag_mcd_power_scale_error',...
  'flag_mcd_attitude_cor_missing',  'flag_mcd_attitude_cor_missing',...
  'flag_mcd_phase_pert_cor_default','flag_mcd_phase_pert_cor_default',...
  'flag_range_av',                  'range_ocean_qual_20_ku',...
  'flag_range_ice_av',              'range_ocog_qual_20_ku',...
  'flag_sigma0_av',                 'sig0_ocean_qual_20_ku',...
  'flag_sigma0_ice_av',             'sig0_ocog_qual_20_ku',...
  'flag_swh_av',                    'swh_ocean_qual_20_ku',...
  'flag_trk',                       'retracking_ocean_qual_20_ku'...
  );
vn={'v_20_dbl', 'v_20_int32', 'v_20_int8'};
for i=1:length(vn)
  flds = fieldnames(v.(vn{i}));
  for j=1:length(flds)
    if isempty(v.(vn{i}).(flds{j}))
      disp(['No matching fieldname for ' flds{j}]);
    elseif isempty(varin.(v.(vn{i}).(flds{j})))
      disp(['No matching data  for field' flds{j}]);
    else
      %    varout.(flds{i}) = blanks;
      %    varout.(flds{i})(ind1:ind1+n_20-1) = varin.(v_20.(flds{i}));
      varout.(flds{j}) = varin.(v.(vn{i}).(flds{j}))';
    end
  end
  % flds = fieldnames(v_20_int8);
  % % blanks = cast(ones(20,n_01), cls).*intmin(cls); % empty matrix for adding data
  % for i=1:length(flds)
  %   if isempty(v_20_int8.(flds{i}))
  %     disp(['No matching field for ' flds{i}]);
  %   else
  %     %     varout.(flds{i}) = blanks;
  %     %     varout.(flds{i})(ind1:ind1+n_20-1) = cast(varin.(v_20_int8.(flds{i})), cls);
  %     varout.(flds{i}) = cast(varin.(v_20_int8.(flds{i})), cls);
  %   end
  % end
  
end

